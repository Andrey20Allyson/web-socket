const http = require('http');
const fs = require('fs');
const serverCache = require('./server-cache');
const easyOs = require('../util/easy-os')


/**@type {import('.').ModuleExportsI} */
const exportsInterface = {
    createServer(requestListener) {
        const requestCacher = serverCache.createRequestCacher();
        const server = http.createServer(requestListener ?? ((req, res) => {
            for (let listener of requestListeners[req.method ?? 'GET'] ?? []) {
                listener(req, res);
                if (!res.writable) break;
            }

            if (req.method === 'GET' && res.writable) {
                if (req.url === '/') {
                    interface.sendData('/index.html', res);
                } else {
                    interface.sendData(req.url, res);
                }
            }
        }));

        /**@type {import('.').RequestListenersI} */
        const requestListeners = {
            CONNECT: [],
            DELETE: [],
            GET: [],
            HEAD: [],
            OPTIONS: [],
            POST: [],
            PUT: [],
            TRACE: []
        };

        let __rootDir = './';
        let __hostname = easyOs.getFirstExternalAddress();

        /**@type {import('./').ServerI} */
        const interface = {
            start(onStart=() => {}, port=80, hostname=__hostname) {
                server.listen(port, hostname, () => onStart(port, hostname));
            },
    
            setRootDir(newDir) {
                __rootDir = newDir;
            },

            sendData(path, res) {
                this.getData(path)
                .then(({data, cached}) => {
                    res.writeHead(cached? 200: 200, {'Content-type': 'text/html'});
                    res.write(data);
                })
                .catch(
                /**
                 * 
                 * @param {NodeJS.ErrnoException} reason
                 */
                reason => {
                    console.log(reason);
                    res.writeHead(404, {'Content-type': 'text/html'});
                    res.write(`Error: ${reason.message}`)
                })
                .finally(() => {
                    res.end();
                });
            }, 
            
            getData(path) {
                return new Promise((resolve, reject) => {
                    let cachedData = requestCacher.getDataFrom(__rootDir + path);

                    if (cachedData) {
                        resolve({
                            data: cachedData,
                            cached: true
                        });
                    } else {
                        fs.readFile(__rootDir + path, {encoding: 'utf-8'}, (err, data) => {
                            if (err) reject(err);

                            requestCacher.insert(data, __rootDir + path);

                            resolve({
                                data,
                                cached: false
                            });
                        });
                    }
                });
            },

            addRequestListener(method, listener) {
                if (method in requestListeners)
                    return requestListeners[method].push(listener);
                
                return 0;
            }
        };

        return interface;
    }
}

module.exports = exportsInterface;